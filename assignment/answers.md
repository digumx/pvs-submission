## Question A.1:
### Part a:

The required proof is saved into `sum_plus.prf` as `sum_of_squares_1`.

### Part b:

The automated proof is saved into `sum_plus.prf` as `sum_of_squares_auto`.

### Part c:

Replacing the `(auto_rewrite_defs)` with `(auto_rewrite_theory "sum_plus")` in `sum_of_squares` did successfully prove the
lemma in my case. The rewrite rules generated included all rewrite rules generated by the original `(auto_rewrite_defs)`,
and also had an extra rewrite rule pertaining to the lemma `sum_plus`.

### Part d:

Since the proof worked, no modification was needed.

## Question B.1:
### Part a:

The command `(assert)` fails because internally it uses the PVS desicion procedures, and to add the formulae in the 
sequent to the internal efficient data structure of true assumption maintained by the desicion procedures it uses
`(record)`. However, `(record)` does not work for recursive `IF` structures without simplification. Internally `(assert)`
uses `(simplify)` to simplify the formulae in the sequent, which can only remove one level of `IF` if it is able to 
resolve the condition to `TRUE`, `FALSE`, or if the condition is already recorded. In the current case no such 
simplifications are possible, and a case split is necessary, and thus `(simplify)` fails to simplify the formulae, and
`(record)` fails to record them. Essencially, assert can simplify propositional expressions only if no case splitting
is necessary because one or more of the predicates can be simplified to truth values. This does not happens in this case,
and so `(assert)` fails.

### Part b:

The command `(split)` fails because split can only split the sequent if there is a formula with a top level disunction,
that is, a formula with `IF` at the top level, an antecedent with `OR` or `IMPLIES` at the top level or a consequent with
`AND` or `<=>` at the top level. The top level construct of the only formula in the sequent in this case is `=`, and so
`(split)` fails.

The recursive definintion of `(prop)` simply tries `(flatten)` and `(split)` repeatedly to recursively remove top level 
propositional connectives in the goal. In this case, the goal has no top level propositional connective, and `(split)`
or `(flatten)` has no effect. Thus, `(prop)` fails.

The command `(ground)` performs propositional simplifications followed by further simplifications performed by `(assert)`.
As the top level connective in the only formula in the sequent is not propositional, no propositional simplification is
possible. We have also seen that `(assert)` itself fails in this case, and thus `(ground)` produces no change.

### Part c:

The required manual proof using `(case)` is saved as `iflemma-1`. The number of case splits was minimised by spliting into 
cases according to the conditions on the right hand side, that is, each condition in the right hand `IF` is a case. This
was achieved by applying case on the disjunction of all the conditions disjuncted with the negation of the conjunction of
all the conditions. The negation term in above was computed by hand. This produces a total of 6 cases.

### Part d:

We note that expressions of the form `F(IF A THEN B ELSE C)` can be transformed so that the top level connective is `IF` by
"lifting" the `IF`, transforming the expression to `IF A THEN F(B) ELSE F(C)`. The `(lift-if)` command looks at all the 
leftmost `IF` connectives in a formula and selects the innermost one to apply the lifting transformation to it.

### Part e:

Applying the `(lift-if)` command lifts all the `IF` conditions on the left of the `=` to above the `=`, transforming the
formula from the form:

```
(IF z = y
         THEN (IF w = v THEN 5
               ELSIF z = x THEN (IF w = u THEN 3 ELSE f(z) ENDIF)
               ELSE f(z)
               ENDIF)
       ELSIF z = x THEN 3
       ELSE f(z)
       ENDIF) = R
```

to the form:

```
(IF z = y
         THEN (IF w = v THEN 5 = R
               ELSIF z = x THEN (IF w = u THEN 3 = R
                                          ELSE f(z) = R
                                          ENDIF)
               ELSE f(z) = R
               ENDIF)
       ELSIF z = x THEN 3 = R
       ELSE f(z) = R
       ENDIF)
```

so that the top level connectives some depth are now `IF`. The command also substitutes `TRUE` or `FALSE` into the instances
of the boolean expression the lifted ifs branch on within the copied instances of `R` depending on which branch of the lifted 
if the instance of `R` lies in. Applying `(ground)` proves the resulting formula. This proof is saved as `iflemma-liftif`.

The command `(lift-if * )` has the exact same effect as `(lift-if)`, and exactly as before the proof can be completed with
`(ground)`. This proof is saved as `iflemma-liftif-star`.

### Part f:

As we saw in the proof of `iflemma`, applying `(lift-if)` to the initial sequent in the proof of `iflemma1` lifts the `IF` to 
the left of the `=` above the `=`, transforming the formula in a manner very similar to how the formula was transformed while
proving `iflemma`. Similar to the previous case, the decision condition expressions for the `IF` in the right hand are substituted
according to which branch the instance of the right hand expression belongs. Applying `(ground)` on the transformed formula
completes the proof, as before. This proof is saved as `iflemma1-1`.

## Problem C.1:
### Part 1:

The `(auto-rewrite-defs)` installs rewrite rules automatically for the definitions of the structural ordering for `aexpt` and
`bexpt`, which comes from an expanded definition defining when an instance of these expression types is structurally smaller
than another. It also installs rewrite rules for the definitions of the functions `aeval` and `Minus`. Additionally, several 
rewrite rules for definitions relevant to proving well-foundedness and totally-orderedness of the order used in the measure
function are also installed. Once the following `(skosimp*)` command reduces the sequent to a form with no quantifiers or 
implications in the goal, the installed rewrite rules are available to `(assert)` which can then use them to automatically
simplify and evaluate the left hand side of the lemma. Even if the form of the arguement to `aeval` is changed, the proof
need not be changed, as the `assert` command automatically evaluates the left hand side regardless of it's form.

### Part 2:

For the `optprop-1` proof, the proof begins by installing auto rewrites corresponding to all cases of the recursive datatypes
and functions with `(auto-rewrite-defs)` and begins an induction on `a`, which is an instance of the inductive datatype `aexpt`. 
This produces 4 subgoals, one for base `ANum` case, and 3 for the other 3 inductive cases. For the first subgoal, `(skosimp*)` 
removes quantifiers and `(assert)` uses auto rewrites to automatically simplify and prove the goal. `(skosimp*)` is used on
the `APlus` case to remove quantifiers, `(assert)` to rewrite using definitions of `Optimize` and `aeval` and then `(lift-if)`
is used to lift the if above the equality so that it is the topmost connective. Then the resulting goal is of the correct form
so that `(assert)` may be used to prove it using the desicion procedures for arithmatic simplification and by rewriting it 
using the available definitions. For the other two cases, the same strategy as the one used in the firs case works, that is, 
using `(skosimp*)` to remove quantifires and implications in the goal, followed by proving the goal using rewrites and 
simplification via the `(assert)` command.

For the `optprop-2` proof, we start as before by installing rewrite rules for necessary definitions via `(auto-rewrite-defs)`
and beginning an induction on `a`, splitting into 4 goals as before. Then, for each goal, we use `(skosimp*)` to remove 
quantifiers and implications, and then apply `(smash)` on it. While `(assert)` can only rewrite based on installed rules and
perform arithmatic simplifications and propositional simplifications when the arguements to the conditionals can be resolved 
to `TRUE` or `FALSE`, `(smash)` repeatedly applies `(bddsimp)` to perform more sophisticated propositional simplification, 
`(lift-if)` to reduce a formula in an equational form to a propositional form, and `(assert)` to perform arithmatic simplification
and rewrites to simplify predicates to truth values. Since in the original proof we saw that a combination of `(assert)` and
`(lift-if)` was sufficient to complete the proof for each of the cases, `(smash)` completes the proof in each case.

We notice in the previous proof that the same commands are being applied in each subgoal generated by the induction. The proof
`optprop-2` uses the strategies `try` and `then` to automate this process. `(try (step1) (step2) (step3))` attempts `(step1)`,
and if it produces more subgoals, applies `(step2)` on the generated subgoals, else if it fails or acts like `(skip)` and
produces no further subgoals, it applies `(step3)` to the original goal. `(then (step1) (step2) ...)` simply applies `(step1)`
to the first goal, then applies `(step2)` to all resulting subgoals and so on. Note that if `(step1)` fails, there is only one
resulting subgoal, which is the original subgoal. Thus, `(step2)` will then act on the original subgoal. The proof uses
`(try (induct "a") (then (skosimp*) (smash)) (skip))`, where the outer `try` attempts induction on `a`, failing which `(skip)`
is called. In this case however, the induction succeeds and `(then (skosimp*) (smash))` is applied to each subgoal generated,
which simply invokes `(skosimp*)` followed by `(smash)` on each subgoal as seen in the previous proof, completing the proof.

### Part 3:

The manual proofs for the TCCs are saved as `<TCC_name>-manual`, where `<TCC_name>` represents the name of the TCC as it appers
in the output of `M-x show-tccs`. For all the TCCs, after installing rewrites, skolemizing and flattening, rewriting with the 
equality in the hypothesis and applying `(assert)` completes the proof.

## Problem C.2:

The required completions were made in `opsemwithstates4class.pvs`. For the datatype `aexpt`, expressions `AConst(n)` represent
a constant `nat` and `AVar(v)` represent reading a variable `v`, the other constructors have the exact same meaning as in 
`opsem.pvs`. For `bexpt`, additional constructors representing the comparision `<` and the connective `OR` were added. The `aeval`
and `beval` functions recursively evaluate arithmatic and boolean expressions by performing substitutions from a given state. The
function `Opt` optimizes expressions recursively by first optimising each of the left and right subexpressions and then reducing
the resulting expression using the following identities:

```
FORALL x: aexpt
    0 + x = x
    x + 0 = x
    0 - x = 0
    x - 0 = l
    0 * x = 0
    x * 0 = 0
    1 * x = l
    x * 1 = x
```
The identities involving `-`, implemented as the function `Minus`, are stated and proved in the lemmas `Minus_0` and `Minus_from_0`.

The theorem `Opt_sound` states that `Opt` is sound, that is, optimizing any arithmatic expression with respect to any state and
then evaluating it with respect to the same state produces the same value as directly evaluating the expression with respect to
the state.

All TCCs generated are manually proved and the proofs are saved under PVS's default names `<tcc_name>-1`, where `<tcc_name>`
represents the name of the TCC generated.

All lemmas and theorems have been proved and the proofs saved to the associated `.prf` file under PVS's default name `<formula_name>-1`,
where `<formula-name>` reperesents the name of the theorem or lemma.

## Problem C.1:
### Part a:

We firstly define a type `Candidate` with 5 possible values to represent candidates. Note that adding or removing candidates can be 
done and the proofs should still hold. Next, we define type `Tally` as a function from by changing this type, no other changes to 
the theory should be necessary, candidates to `nat` to store the tally of each candidate. We define `tally_plus` to add two tallies
together.

Next, we define the inductive type `VoteSequence` to store a sequence of votes. It has two constructors, `Null` makes an empty 
sequence and `Vote` adds a vote to an existing sequence.

Now, we define some functions related to `VoteSequence` that will become useful later. `size` returns the size of a `VoteSequence`
inductively. `concat` concatenates two `VoteSequence`s.

We firstly assert that the only `VoteSequence` with size 0 is `Null` in the lemma `Size_0_Null`. We prove this by induction on
`v`, where as the base case has the same antecedent and consequent formula, it is automatially handled. For the inductive case,
the antecedent will have an expression of the form `size(Vote(...)) = 0` which when rewritten with the definition of `(size)`
will reduce to the form `1 + ... = 0`, which is a contradiction. This rewrite can be performed by `(assert)`, and this
completes the proof.

We state the lemma `Concat_Size` to express that the size of the concatenation of two `VoteSequence`s will be the sum of their 
sizes. We prove this by inducting on the second sequence by `(induct)`, and as each case can be proved by direct rewrites,
`(assert)` suffices.

We define `tally_null` to represent the 0 `Tally` and `tally_cand(c)` to represent the `Tally` where `c: Candidate` has recieved
a singel vote, and no one else has recieved a vote. We define functon `tally_sum` to add two tallies together, the addition is done
point wise. The recursive function `tally_votes` calculates the tally of each candidate in a given vote sequence.

We now define the lemma `Concat_Tally` to state that the tallies of concatenated vote sequences are the sum of the tallies of the
sequences. To prove this, we remove quantifications via `(skosimp*)` and apply `(extensionality)` to reduce the functional equation
to a simplified form. Then, we regeneralize with `(generalize-skolem-constants)` and start induction with `(induct)`. Now, for each
case, a combination of `(assert)` and `(rewrite)` suffices.

The lemma `Tally_2` states that for any two distinct candidates, the sum of their tallies over any vote sequence is at most the 
size of the vote sequence. We prove this by induction on `v`. The base case is proved by performing simple rewrites with `(assert)`.
For the inductive case, we case split simplify the sequent using `(skosimp*)` and case split based on if the two candidates are
equal. Then, we use `(rewrite)`, `(lift-if)` and `(bddsimp)` to automatically split into cases resolving the `tally_cand` 
expressions. For each resulting subgoal, directly rewriting with `(assert)` proves the goal.

Our algorithm acts iteratively by updating a counter and a `Candidate` variable by reading one vote at a time. We capture this
behavior by defining the recursive fucntion `majority` which takes a `VoteSequence` and inductively returns the state of the 
algorithm after acting on this sequence. We define the state of the algorithm in the datatype `State`, which is just a pair of
`Candidate` and `nat`. We initially set the candidate tracker to `A`, changing this to any candidate should not invalidate any
proof.

Now, we define `majority` to take the `State` returned by `maj` and give a `Candidate`.

### Part b:

The correctness of the algorithm is stated by the theorem `Majority_Correct`. A candidate has majority if he has more than half the
votes, that is, if in the vote sequence twice his tally is more than size of the sequence. So, given that this happens, if our
algorithm is correct, it should return this candidate. This is what the theorem captures.

### Part c:

To prove `Majority_Correct`, we prove a series of lemmas and invariants. To do this, we must track certain extra states through 
`maj`. These will not affect the computation, but will help us to express invariants. To do this, we redefine a copy of `maj`
as `maj2` with extra stases. The `State2` datatype represents `maj_ext`'s state, with `c2` and `n2` being copies of `c` and
`n`. `vz` tracks the subsequence of the vote sequence since the last time 0 was encountered to to the current vote, including
the vote before which the counter was 0 for the last time, and `vr` tracks the rest of the vote sequence upto that point. We
capture this inductively by adding the last vote `vz` and keeping `vr` the same if the last vote did not make the counter 0, else
we make `vz` `Null` and concatenate all it's contents along with the last vote to `vr`.

The first thing we prove is the lemma `Maj_Maj2_Equiv` which states that the candidate and counter tracked by `maj` and `maj2`
are the same at all times. We prove this by first initiating induction using `(induct)`. For the two base cases generated,
we rewrite with `(assert)` to complete the proof. For the inductive case, using `(skosimp*)` to remove quantifications and
implications, we use `(smash)` to automatically case split, rewrite and complete the proof.

Next, we prove the lemma `Maj2_Concat`, which states that the two `VoteSequence`s being tracked in the extended state when
concatenated gives the original `VoteSequence`. We do this by `(induct v)`, and the base case is handled by rewriting with
`(assert)`. For the inductive case, we use `(skosimp*)` to remove quantifications and implications. Then, we must case split
based on if the counter becomes 0, and in each case rewriting with the definitions of `maj2` and `concat` suffices. As the
case split is apparent from the `IF` in the definition of `maj2`, it is automatically handled by `(smash)`, and `(smash)`
completes the proof.

Now, we prove the lemma `Maj2_0_Vz_Null` which states that if the counter returned by `maj2` is 0, then `vz` returned by it
must be null. We prove this by induction. The base case can be proven by direct rewrites, and `(assert)` suffices. For the
induction case, we case split based on the `IF` in the definition of `maj2`. For all cases other than the last `ELSE`, we
must have a contradiction, as the counter cannot be zero after the vote. In the last `ELSE` case, rewriting gives us that the
output for `vz` must be `NULL`. Thus, using `(smash)`, we can automatically perform the case splits, reductions and rewrites
to conclude the proof.

The first invariant we prove is stated by `Maj2_Inv0`, which simply states that `vr` is such that after processing it the value
of the counter is indeed 0. We prove this via induction on `v`. The base case is handled automatically by rewriting with `(assert)`.
For the inductive case, we use `(rewrite maj2)` followed by `(lift-if)` and `(bddsimp)` to break into cases based on which branch
of `maj2`'s `IF` was executed for the last vote. The first three cases can be proved by direct rewriting, and are discharged by
`(assert)`. For the final `ELSE` case, we use `(beta)` reduce to remove the accessor on constructor expression, and use 
`Maj2_Concat` to remove the concatenation. Then, using `(rewrite maj2)` followed by `(lift-if)` and `(bddsimp)` we automatically
handle the cases of the remaining `maj2` in the consequent, and because of the other consequent expression, `(bddsimp)` reduces
all but the last `ELSE` case to tautologies and discharges them automatically. Now, for this case, a direct rewrite with
`(assert)` completes the proof.

Our proof strategy is to emulate the proof submitted in Assignment 1, and we see that in that proof in one case, we talk about
the stretch of latestmost votes where a single candidate was being tracked and argue about the majority for this stretch. This 
stretch, in our case, is `vz`, and to argue the about the majority, we prove our first invariant  `Maj2_Inv1`, which states that 
for all `v: VoteSequence`, the candidate tracked at the end of the sequence leads over all other candidates combined by the value
of the counter at that point.

We prove this by using `(induct v)`. The base case involves direct rewriting as all conditionals in all definitions are resolved,
and `(assert)` should suffice.

For the inductive case, we must case split based on the `IF` condition within `maj2`, and we do this and simplify in a single step
using `(smash)`. In the first case we have that the counter before the last vote was 0, and we apply `Maj2_0_Vz_Null` to rewrite 
the `vz` before the last vote to `Null` in the consequent, and rewrite directly using `(assert)` to complete the proof. Since in
the other cases all conditionals are fully resolved, direct rewriting will prove the sequent, and the `(smash)` used to split the
cases should handle these cases automatically.

Now we wish to prove our correctness theorem by strong induction over the size of `VoteSequence`. To do this, we define the lemma
`Maj2_Inv` which says that for all natural number `N`, and for all `v: VoteSequence` of size at most `N`, and for all `c: Candidate`,
if `c` holds a majority in `v`, we must have that `c2(maj2(v)) = c`. Then, proving this formula by induction on `N` is essencially
performing strong induction on the size of the `VoteSequence`. We also add the condition that the counter gives us the number of
votes by which the candidate leads over all the rest combined, this will be useful as an invariant condidtion.

#### Proof of Maj2_Inv2:

To prove the lemma, we use `(skolem!)` to remove the outermost quantification, and then initiate induction with `(induct N)`. The 
base case is when `N` is 0 or lesser, and simplifying with `(skosimp*)`, rewriting with `Size_0_Null` using `(rewrite)` followed 
by using `(assert)` leads to a contradiction as for `Null`, majority of any candidate cannot hold.

For the inductive case, we have that for any `N`, an implication between two formulae quantified over all `v: VoteSequence` must 
hold. We use `(skolem!)` and `(flatten)` to simplify the sequent to a form where one of these formulae is the antecedent, and the 
other is the consequent. These formulas themeslves will be of the form `size(v) < N IMPLIES ...`, and `size(v) < N+1 IMPLIES ...`.
We again apply induction, this time on `v`. The base case is proved by rewriting directly using `(assert)`.For the inductive case, 
`(skosimp*)` lands us in the required sequent for our desired strong induction.

We define a general pattern for case splitting manually using `(case)`. If we want to case split based on if some `P` holds, then
`(case P)` will produce a subgoal where we will have to prove `P` holds from the antecedents. To avoid this, we instead use
`(case "P OR NOT P")`. This produces two subgoals, one of which has `P OR NOT P` as a consequent, and can be handled by `(smash)`.
The other case can be split into the two required cases by using `(split)`.

We use the pattern above to case split based on weather the candidate who held the majority over the entire sequence also held a
majority before the last vote. In the case where it did, we have several possible cases to consider, according to the `IF`s in
the definition of `maj2` and the definitions of the tally related functions. These are based on the value of the counter before
the last vote, and the equality between the candidate being tracked, the candidate recieving the last vote, and the candidate 
holding the majority. However in all of these cases but one, direct rewriting produces contradiction, and in the case it doesnt,
rewriting with the structural induction hypothesis in the antecedent completes the proof. Thus, `(smash)` proves this subgoal.

In the case the majority was not held before the last vote, we again use `(case)` to split into cases based on weather the last
vote went to the candidate holding the majority. In the case it did not, we can arrive at a contradiction directly by rewriting
using `(assert)`, as all necessary conditionals are resolved. Thus, we have that the last vote went to the candidate holding
the majority.

Now, we case split using `(case)` again, this time based on if the counter was 0 before the last vote. If it was, directly 
rewriting will show the required consequents, as all conditionals in the consequent are fully resolved. So, in this subgoal, an
`(assert)` suffices.

If the counter was nonzero before the last vote, we use `(case)` to again case split based on weather the majority candidate was
being tracked before the last vote. If it was, all conditionals are resolved, and we notice that direct rewrites proves the case.
Thus, `(assert)` suffices for this subgoal.

Finally, we have the case where the majority candidate was not being tracked before the last vote. In this case, we need to talk
about the stretch for which the candidate before the last vote was tracked, which is `vz`. Then, `Maj2_Inv1` gives us an
expression for how much this candidate leads over all others in `vz`. We then use the `Tally_2` lemma to reduce this to an 
inequality involving the tally of the majority candidate. The `Concat_Tally` lemma after rewriting with `Maj2_Concat` then gives 
us that the majority candidate must hold a majority in `vr`. Now, the induction hypothesis, which is quantified over all 
`VoteSequences` of all size, combined with `Maj2_Inv0`, applied on `vr` and the vote sequence corresponding to `vs` in the 
definition of `maj2` respectively, will produce an equality for how much the majority candidate leads over everyone else combined.
For each of the lemmas above, we add them as antecedants with the required substitutions using `(lemma)`. In cases where the
statement of the lemma added is further universally quantified, we remove the quantification via `(instantiate)` with the 
mentioned substitutions. In case the statement of the lemma simplifies to an equality of functions, we use `(decompose-equality)`
with proper substitutions to reduce to an expression for a particular point in the function's range. Now, we introduce the lemma
`Concat_size` to add an equality required to relate the `size` expressions for `vr` and `vz`. We simplify the `concat` in this 
by rewriting using `Maj2_Concat` via `(rewrite)`. Now, using `(assert)` is sufficient to automatically simplify the arithmatic
expressions produced in the antecedant and complete the proof.

#### Q.E.D.

Finally, we can prove our correctness theorem. This can be proved by firstly removing all quantifications and implications via
`(skosimp*)`. Then, we rewrite using the definition of `majority`, and then rewrite using `Maj_Maj2_Equiv` to reduce the problem
in terms of `maj2`. Now, we use `(lemma)` to instanciate a version of the lemma `Maj2_Inv2` with `v` and `c` substituted as `v`
and `c`, while we substitute `N` as `size(v)`. Then, automatically rewriting using `(assert)` will complete the proof.

## Problem C.2:

For all lemmas and theorems other than `Maj2_Inv2`, the proof is saved as the PVS default `<formula_name>-1` where `<formula_name>`
represents the name of the lemma or theorem. The proof of `Maj2_Inv2` is saved as `Maj2_Inv2-2`. Please ignore the incomplete
proof saved as `Maj2_Inv2-1`, if it exists.

All TCCs have been proved and the proofs have been saved as the PVS default `<tcc_name>-1` where `<tcc_name>` represents the name
of the TCC.

## Problem C.3:
### Part a:

We firstly define `Ball` as a type that may iether by `B` for a black ball, or `W` for a white ball. We define our representation
of bag in the type `Bag`, which is a tuple of natural numbers. The first member counts the number of black balls, and the second
counts the number of white balls in the bag. We also define some basic properties of `Bag`, like it's `size` as the sum of the
individual counts. The functions `add_b` and `add_w` add a black and a white ball to a given bag, respectively. Similarly, we
define `remove_b` and `remove_w` to remove a black and white ball from a bag with atleast one black and white ball, respectively.
We restruct the domain of these functions to accept only bags from which the required ball can be removed. The function `even_black?`
returns weather the given `Bag` has an even number of black balls. 

As the ball game only makes sense as long as bags are not empty, we define a type `NonemptyBag` as a subtype of `Bag`.

Now we define the nondeterministic `pick_2` function, which returns a tuple of type `[Ball, Ball]` from a given `Bag` of size 
atleast 2, representing a possible pair of balls that may be picked from the bag. Since `pick2` is nondeterministic, we must 
define the return value as an arbitrary member of a set of allowed return values, and we achieve this by using the prelude theories 
`set` and `epsilon` in our specification. This means that we must define for a given input bag `bg` the possible allowed ball-ball 
tuples the function can return as a predicate on all possible ball-ball tuples. We define this predicate as the check that for the
given ball-ball tuple, the required number of balls is present in `bg`. This is defined as `pick_2_pred`. 

We note that to be able to reduce the `epsilon` in the definition, the only tool at our disposal is `epsilon_ax`, which can only 
be applied on nonempty predicates, as the arbitrary choice function represented by `epsilon` does not make sense for empty 
predicates. To ensure nonemptyness, we restrict the domain to those bags with atleast two elements. This will give us enough 
antecedants to apply `epsilon_ax` wherever the `pick_2` function appears, and produce tccs which oblige us to prove these 
antecedants. This nonemptiness is stated in the lemma `Pick_2_Pred_Nonempty`.

Next we define the function `ball_step`, which takes a `Bag` with atleast 2 elements and returns a `Bag` after performing a single
step of the ball game on it. We use the `pick_2` function to pick two balls here.

Now we can implement the iterative ball game as the recursive function `ball_game`. In this function, we check if the given bag
has size 1, then we return the last ball in the bag, else we recursively call the function on the bag after performing a `ball_step`
on it. We require that the input bag be nonempty.

### Part b:

The theorem we would like to prove says that the final ball in the bag after `ball_game` terminates is white if there was an even
number of black balls initially, else it is black. This is straight forward to express using our given definitions, as for any
`Bag`, `even_black?` checks weather the number of black balls is even, and `ball_game` returns the last ball in the bag after
the termination of the game. Thus the required property is captured as the following theorem:

```
Last_Ball: THEOREM FORALL (bg: NonemptyBag): IF even_black?(bg) THEN ball_game(bg) = W ELSE ball_game(bg) = B ENDIF
```

We note that the `pick_2` function is defined nondeterministically as an arbitrary member of a set using the `epsilon` function
defined in the prelude, and all other functions including `ball_game` are defined in terms of it. Thus, it is not possible in
general to rewrite `ball_game` directly to a concrete return value, as there is no way to rewrite the return value of `epsilon`
to a concrete member of the return type. However, the above theorem states that nonetheless, if we know the initial parity of
black balls in the bag, we can rewrite the return value of `ball_game` to a concrete member of the type `Ball`. 

### Part c:

Firstly, we prove that no matter what the nondeterministic function `ball_step` does, it does indeed reduce the size of the `Bag`.
This will be necessary for using measure induction on the size of the `Bag`. This can be proved by rewriting `ball_step`, and
using `(smash)` to automatically case split and rewrite to prove each case.

To prove the required theorem we first prove that `even_black?` is an invariant for the iteration in the ball game. As each step
of the ball game is given by transforming the `Bag` according to `ball_step`, the invariant must have same values for the input
and output of `ball_step`. We express this in a lemma `Even_Black_Inv`.

To prove the lemma, we first remove the outermost quantification with `(skolem!)`, and then `(rewrite ball_step)`, introducing the 
`IF` expression in the definition. We notice that regardless of the complex condition involving the nondeterministic `pick_2` 
condition, replacing the `IF` condition with any of the branches can directly prove the required equivalence by simple rewrites. 
Thus, we use `(smash)` to automatically case split and perform the rewrites. As the `even?` fucntion is defined in the prelude as
an existencial expression, `(smash)` fails to prove the equivalence of `even?(n)` and `even?(n + 2)`, which we do manually using
skolemization and appropriate instanciation via `(skosimp*)` and `(inst)`.

Now we prove our theorem by strong induction using `size` as a measure function. To do so, we install rewrites with 
`(auto-rewrite-defs)` and initiate induction with `(measure-induct)`. Then, using `P(b: Bag)` to represent our predicate, we have
a consequent of the form `P(bg)` and an antecedent of the form `FORALL (b: Bag) size(b) < size(bg) IMPlIES P(b)`. The predicate
itself is an `IF` expression, and expanding the definition of `ball_game` gives us another nested `IF` expression, this time based
on weather we are in the base case or recursive case for `ball_game`. We case split on these `IF`'s conditions and automatically
simplify with `(smash)`.

First we have the case where the outer `IF`'s condition is true, that is, the bag `bg` has an even number of black balls. Then,
for the base case of `ball_game`, direct rewriting completes the proof, and `(smash)` automatically discharges this case. For
the recursive case, we use `Ball_Step_Reduce` to argue that the size of `ball_step(bg)` is less than the size of `bg`, allowing
us to apply the induction hypothesis. Then, `Even_Black_Inv` gives us that the number of black balls in `ball_step(bg)` is even,
and appying the induction hypothesis completes the proof. To do this, we introduce the relevant lemmas with proper substitution
using `(lemma)`, reduce the `IFF` to implications with `(flatten)`, and instantiate the induction hypothesis for `ball_step(bg)`
with `(inst)`. Then, performing automatic case splits and rewriting with `(smash)` completes the proof of this case.

Now, we come to the case where the bag `bg` has an odd number of black balls. For the base case, as size is 1, we have two 
possibilities for the bag `bg`, `(1, 0)` or `(0, 1)`. One of these is what we need to show, and for the other, we have a 
contradiction with the condition that `bg` has an odd number of balls. To follow this arguement in PVS, we introduce the two cases 
for `Bag` using `(case)`, as we have done previously in the majority problem. One case is immediately discharged, and for the 
other case, we arrive at a contradiction by instanciating the existential evenness condition with 0 as the quotient when the 
number of black balls is divided by 2. To discharge the remaining subgoal `bg = (1, 0) OR bg = (0, 1)`, we use `(flatten)` to 
remove the outer `OR` and then use `(decompose-equality)` to reduce the consequent expressions to purely arithmatic forms. Then, 
`(assert)` suffices.

Finally, for the recursive case where the bag `bg` has an odd number of black balls, we use `Ball_Step_Reduce` to argue that we 
can apply the induction hypothesis in `ball_step(bg)`, and use `Even_Black_Inv` to argue that the number of black balls in 
`ball_step(bg)` is odd. Then, applying the induction hypothesis, we complete the prove. To do this in PVS, we introduce instances 
of each lemma used with proper substitution using `(lemma)`, reduce `IFF` to implications using `(flatten)`, and instantiate the 
induction hypothesis with `ball_step(bg)` with `(inst)`. Then, using `(smash)` to automatically case split and rewrite completes 
the proof.

## Problem E.2:

For all lemmas and theories, the proof is saved as the PVS default `<formula_name>-1`, where `<formula_name>` represents the name 
given to the theory.

To prove the subtype tccs generated by the instances of the `remove_*` functions in the definition of `ball_step`, we need to apply
`epsilon_ax`, and for that we need to prove the lemma `Pick_2_Pred_Nonempty`. To do so, we first simplify via `(skosimp*)`, and
introduce the type predicate for the bag via `(typepred)`. Then, we use `(case)` to case split into three cases, one where the bag
has atleast two black balls, one where there are atleast two white balls, and one where there is exactly one black and one white
ball. In each case, we instanciate the existential formula in the sequent via `(inst)` with `(B, B)`, `(W, W)` and `(B, W)` 
respectively, and rewrite directly with `(assert)` to complete the proof.

The tccs generated in `ball_step` for the `IF` and `ELSIF` cases are proved by simplifying with `(skosimp*)`, and introducing the
`epsilon_ax` and `Pick_2_Pred_Nonempty` with proper substitutions via `(lemma)`. Then rewriting and using `(smash)` completes the
proof. For the `ELSE` case, before we follow the above steps we use `(case)` to introduce `p2!1 = (W, W)` as an antecedent. Then,
the proof for the first subgoal generated is as above. For the second subgoal, we use `(case)` to split based on weather the 
componenets of `p2!1` are black or white, giving us 4 subgoals. For each, we use `(decompose-equality)` on the corresponding 
succeedent formula to complete the proof.

All other subtype tccs were proved by simplifying with `(skosimp*)`, introducting type predicates for `Bag` type variables, and
automatically case splitting and simplifying with `(smash)`.
